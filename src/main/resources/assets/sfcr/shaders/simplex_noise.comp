#version 440

const dvec3 GRADIENTS[16] = { dvec3(1, 1, 0), dvec3(-1, 1, 0), dvec3(1, -1, 0), dvec3(-1, -1, 0), dvec3(1, 0, 1), dvec3(-1, 0, 1), dvec3(1, 0, -1), dvec3(-1, 0, -1), dvec3(0, 1, 1), dvec3(0, -1, 1), dvec3(0, 1, -1), dvec3(0, -1, -1), dvec3(1, 1, 0), dvec3(0, -1, 1), dvec3(-1, 1, 0), dvec3(0, -1, -1) };
const double SQRT_3 = 1.7320508075688772;
const double SKEW_FACTOR_2D = 0.5 * (SQRT_3 - 1.0);
const double UNSKEW_FACTOR_2D = (3.0 - SQRT_3) / 6.0;

layout (std140, binding = 0) uniform simplex_noise_permutation
{
    int permutation[512];
};

int map(int i) {
    return permutation[i & 255];
}

double grad(int hash, dvec3 pos, double distance) {
    double d = distance - pos.x * pos.x - pos.y * pos.y - pos.z * pos.z;
    double e = 0.0;
    if (d < 0.0) {
        e = 0.0;
    } else {
        d *= d;
        dvec3 g = GRADIENTS[hash];
        e = d * d * dot(g, pos);
    }

    return e;
}

layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

// Requires size to be the same as group size
// <group size> = ceil(imageSize(sample_result) / vec3(8, 8, 8))
layout (binding = 1, rgba32i) uniform readonly restrict iimage3D sample_group_offset;

layout (binding = 2, r32f) uniform writeonly restrict image3D sample_result;

double do_sample(dvec3 pos) {
    double d = 0.3333333333333333;
    double e = (pos.x + pos.y + pos.z) * 0.3333333333333333;
    ivec3 ijk = ivec3(floor(pos + e));
    double f = 0.16666666666666666;
    double g = double((ijk.x + ijk.y + ijk.z) * 0.16666666666666666);
    dvec3 hlm = dvec3(ijk.x - g);
    dvec3 nop = pos - hlm;
    ivec3 qrs;
    ivec3 tuv;
    if (nop.x >= nop.y) {
        if (nop.y >= nop.z) {
            qrs = ivec3(1, 0, 0);
            tuv = ivec3(1, 1, 0);
        } else if (nop.x >= nop.z) {
            qrs = ivec3(1, 0, 0);
            tuv = ivec3(1, 0, 1);
        } else {
            qrs = ivec3(0, 0, 1);
            tuv = ivec3(1, 0, 1);
        }
    } else if (nop.y < nop.z) {
        qrs = ivec3(0, 0, 1);
        tuv = ivec3(0, 1, 1);
    } else if (nop.x < nop.z) {
        qrs = ivec3(0, 1, 0);
        tuv = ivec3(0, 1, 1);
    } else {
        qrs = ivec3(0, 1, 0);
        tuv = ivec3(1, 1, 0);
    }

    dvec3 wab = nop - dvec3(qrs) + 0.16666666666666666;
    dvec3 acde = nop - dvec3(tuv) + 0.3333333333333333;
    dvec3 afgh = nop - 1.0 + 0.5;
    ivec3 aijk = ijk & 255;
    ivec4 almno = ivec4(
        map(aijk.x + map(aijk.y + map(aijk.z))),
        map(aijk.x + qrs.x + map(aijk.y + qrs.y + map(aijk.z + qrs.z))),
        map(aijk.x + tuv.x + map(aijk.y + tuv.y + map(aijk.z + tuv.z))),
        map(aijk.x + 1 + map(aijk.y + 1 + map(aijk.z + 1)))
    ) % ivec4(12);
    double ap = grad(almno.x, nop, 0.6);
    double aq = grad(almno.y, wab, 0.6);
    double ar = grad(almno.z, acde, 0.6);
    double as = grad(almno.w, afgh, 0.6);
    return 32.0 * (ap + aq + ar + as);
}

void main() {
    ivec3 total_size = imageSize(sample_result);
    if (gl_GlobalInvocationID.x >= total_size.x || gl_GlobalInvocationID.y >= total_size.y || gl_GlobalInvocationID.z >= total_size.z) return;
    ivec3 offset = imageLoad(sample_group_offset, ivec3(gl_WorkGroupID)).xyz;
    dvec3 pos = dvec3(ivec3(gl_LocalInvocationID) + offset);
    double result = do_sample(pos);
    imageStore(sample_result, ivec3(gl_GlobalInvocationID), vec4(result));
}
